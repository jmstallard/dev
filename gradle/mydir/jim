










<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">



[ruby] Contents of /trunk/misc/ruby-mode.el








/[ruby]/trunk/misc/ruby-mode.el




Contents of /trunk/misc/ruby-mode.el



 Parent Directory

|  Revision Log








Revision 44033 -
(show annotations)



Fri Dec  6 07:47:47 2013 UTC
(5 months, 2 weeks ago)
by nobu







File size: 61285 byte(s)






ruby-mode.el: expand/unexpand block

* misc/ruby-mode.el (ruby-brace-to-do-end): split single line block.
* misc/ruby-mode.el (ruby-do-end-to-brace): shrink single line block
  to one line.



















1

;;; ruby-mode.el --- Major mode for editing Ruby files







2









3

;; Copyright (C) 1994, 1995, 1996 1997, 1998, 1999, 2000, 2001,







4

;;   2002,2003, 2004, 2005, 2006, 2007, 2008







5

;;   Free Software Foundation, Inc.







6









7

;; Authors: Yukihiro Matsumoto, Nobuyoshi Nakada







8

;; URL: http://www.emacswiki.org/cgi-bin/wiki/RubyMode







9

;; Created: Fri Feb  4 14:49:13 JST 1994







10

;; Keywords: languages ruby







11

;; Version: 0.9







12









13

;; This file is not part of GNU Emacs. However, a newer version of







14

;; ruby-mode is included in recent releases of GNU Emacs (version 23







15

;; and up), but the new version is not guaranteed to be compatible







16

;; with older versions of Emacs or XEmacs. This file is the last







17

;; version that aims to keep this compatibility.







18









19

;; You can also get the latest version from the Emacs Lisp Package







20

;; Archive: http://tromey.com/elpa







21









22

;; This file is free software: you can redistribute it and/or modify







23

;; it under the terms of the GNU General Public License as published by







24

;; the Free Software Foundation, either version 3 of the License, or







25

;; (at your option) any later version.







26









27

;; It is distributed in the hope that it will be useful, but WITHOUT







28

;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY







29

;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public







30

;; License for more details.







31









32

;; You should have received a copy of the GNU General Public License







33

;; along with it.  If not, see &lt;http://www.gnu.org/licenses/&gt;.







34









35

;;; Commentary:







36









37

;; Provides font-locking, indentation support, and navigation for Ruby code.







38

;;







39

;; If you&#39;re installing manually, you should add this to your .emacs







40

;; file after putting it on your load path:







41

;;







42

;;    (autoload &#39;ruby-mode &quot;ruby-mode&quot; &quot;Major mode for ruby files&quot; t)







43

;;    (add-to-list &#39;auto-mode-alist &#39;(&quot;\\.rb$&quot; . ruby-mode))







44

;;    (add-to-list &#39;interpreter-mode-alist &#39;(&quot;ruby&quot; . ruby-mode))







45

;;







46









47

;;; Code:







48









49

(defconst ruby-mode-revision &quot;$Revision$&quot;







50

  &quot;Ruby mode revision string.&quot;)







51









52

(defconst ruby-mode-version







53

  (and (string-match &quot;[0-9.]+&quot; ruby-mode-revision)







54

       (substring ruby-mode-revision (match-beginning 0) (match-end 0)))







55

  &quot;Ruby mode version number.&quot;)







56









57

(defconst ruby-keyword-end-re







58

  (if (string-match &quot;\\_&gt;&quot; &quot;ruby&quot;)







59

      &quot;\\_&gt;&quot;







60

    &quot;\\&gt;&quot;))







61









62

(defconst ruby-block-beg-keywords







63

  &#39;(&quot;class&quot; &quot;module&quot; &quot;def&quot; &quot;if&quot; &quot;unless&quot; &quot;case&quot; &quot;while&quot; &quot;until&quot; &quot;for&quot; &quot;begin&quot; &quot;do&quot;)







64

  &quot;Keywords at the beginning of blocks.&quot;)







65









66

(defconst ruby-block-beg-re







67

  (regexp-opt ruby-block-beg-keywords)







68

  &quot;Regexp to match the beginning of blocks.&quot;)







69









70

(defconst ruby-non-block-do-re







71

  (concat (regexp-opt &#39;(&quot;while&quot; &quot;until&quot; &quot;for&quot; &quot;rescue&quot;) t) ruby-keyword-end-re)







72

  &quot;Regexp to match&quot;)







73









74

(defconst ruby-indent-beg-re







75

  (concat &quot;\\(\\s *&quot; (regexp-opt &#39;(&quot;class&quot; &quot;module&quot; &quot;def&quot;) t) &quot;\\)\\|&quot;







76

          (regexp-opt &#39;(&quot;if&quot; &quot;unless&quot; &quot;case&quot; &quot;while&quot; &quot;until&quot; &quot;for&quot; &quot;begin&quot;)))







77

  &quot;Regexp to match where the indentation gets deeper.&quot;)







78









79

(defconst ruby-modifier-beg-keywords







80

  &#39;(&quot;if&quot; &quot;unless&quot; &quot;while&quot; &quot;until&quot;)







81

  &quot;Modifiers that are the same as the beginning of blocks.&quot;)







82









83

(defconst ruby-modifier-beg-re







84

  (regexp-opt ruby-modifier-beg-keywords)







85

  &quot;Regexp to match modifiers same as the beginning of blocks.&quot;)







86









87

(defconst ruby-modifier-re







88

  (regexp-opt (cons &quot;rescue&quot; ruby-modifier-beg-keywords))







89

  &quot;Regexp to match modifiers.&quot;)







90









91

(defconst ruby-block-mid-keywords







92

  &#39;(&quot;then&quot; &quot;else&quot; &quot;elsif&quot; &quot;when&quot; &quot;rescue&quot; &quot;ensure&quot;)







93

  &quot;Keywords where the indentation gets shallower in middle of block statements.&quot;)







94









95

(defconst ruby-block-mid-re







96

  (regexp-opt ruby-block-mid-keywords)







97

  &quot;Regexp to match where the indentation gets shallower in middle of block statements.&quot;)







98









99

(defconst ruby-block-op-keywords







100

  &#39;(&quot;and&quot; &quot;or&quot; &quot;not&quot;)







101

  &quot;Block operators.&quot;)







102









103

(defconst ruby-block-hanging-re







104

  (regexp-opt (append ruby-modifier-beg-keywords ruby-block-op-keywords))







105

  &quot;Regexp to match hanging block modifiers.&quot;)







106









107

(defconst ruby-block-end-re &quot;\\_&lt;end\\_&gt;&quot;)







108









109

(defconst ruby-here-doc-beg-re







110

  &quot;\\(&lt;\\)&lt;\\(-\\)?\\(\\([a-zA-Z0-9_]+\\)\\|[\&quot;]\\([^\&quot;]+\\)[\&quot;]\\|[&#39;]\\([^&#39;]+\\)[&#39;]\\)&quot;)







111









112

(defconst ruby-here-doc-end-re







113

  &quot;^\\([ \t]+\\)?\\(.*\\)\\(.\\)$&quot;)







114









115

(defun ruby-here-doc-end-match ()







116

  (concat &quot;^&quot;







117

          (if (match-string 2) &quot;[ \t]*&quot; nil)







118

          (regexp-quote







119

           (or (match-string 4)







120

               (match-string 5)







121

               (match-string 6)))))







122









123

(defun ruby-here-doc-beg-match ()







124

  (let ((contents (concat







125

                   (regexp-quote (concat (match-string 2) (match-string 3)))







126

                   (if (string= (match-string 3) &quot;_&quot;) &quot;\\B&quot; &quot;\\b&quot;))))







127

    (concat &quot;&lt;&lt;&quot;







128

            (let ((match (match-string 1)))







129

              (if (and match (&gt; (length match) 0))







130

                  (concat &quot;\\(?:-\\([\&quot;&#39;]?\\)\\|\\([\&quot;&#39;]\\)&quot; (match-string 1) &quot;\\)&quot;







131

                          contents &quot;\\(\\1\\|\\2\\)&quot;)







132

                (concat &quot;-?\\([\&quot;&#39;]\\|\\)&quot; contents &quot;\\1&quot;))))))







133









134

(defconst ruby-delimiter







135

  (concat &quot;[?$/%(){}#\&quot;&#39;`.:]\\|&lt;&lt;\\|\\[\\|\\]\\|\\_&lt;\\(&quot;







136

          ruby-block-beg-re







137

          &quot;\\)\\_&gt;\\|&quot; ruby-block-end-re







138

          &quot;\\|^=begin\\|&quot; ruby-here-doc-beg-re)







139

  )







140









141

(defconst ruby-negative







142

  (concat &quot;^[ \t]*\\(\\(&quot; ruby-block-mid-re &quot;\\)\\&gt;\\|&quot;







143

          ruby-block-end-re &quot;\\|}\\|\\]\\)&quot;)







144

  &quot;Regexp to match where the indentation gets shallower.&quot;)







145









146

(defconst ruby-operator-chars &quot;-,.+*/%&amp;|^~=&lt;&gt;:&quot;)







147

(defconst ruby-operator-re (concat &quot;[&quot; ruby-operator-chars &quot;]&quot;))







148









149

(defconst ruby-symbol-chars &quot;a-zA-Z0-9_&quot;)







150

(defconst ruby-symbol-re (concat &quot;[&quot; ruby-symbol-chars &quot;]&quot;))







151









152

(defvar ruby-mode-abbrev-table nil







153

  &quot;Abbrev table in use in ruby-mode buffers.&quot;)







154









155

(define-abbrev-table &#39;ruby-mode-abbrev-table ())







156









157

(defvar ruby-mode-map nil &quot;Keymap used in ruby mode.&quot;)







158









159

(if ruby-mode-map







160

    nil







161

  (setq ruby-mode-map (make-sparse-keymap))







162

  (define-key ruby-mode-map &quot;{&quot; &#39;ruby-electric-brace)







163

  (define-key ruby-mode-map &quot;}&quot; &#39;ruby-electric-brace)







164

  (define-key ruby-mode-map &quot;\e\C-a&quot; &#39;ruby-beginning-of-defun)







165

  (define-key ruby-mode-map &quot;\e\C-e&quot; &#39;ruby-end-of-defun)







166

  (define-key ruby-mode-map &quot;\e\C-b&quot; &#39;ruby-backward-sexp)







167

  (define-key ruby-mode-map &quot;\e\C-f&quot; &#39;ruby-forward-sexp)







168

  (define-key ruby-mode-map &quot;\e\C-p&quot; &#39;ruby-beginning-of-block)







169

  (define-key ruby-mode-map &quot;\e\C-n&quot; &#39;ruby-end-of-block)







170

  (define-key ruby-mode-map &quot;\e\C-h&quot; &#39;ruby-mark-defun)







171

  (define-key ruby-mode-map &quot;\e\C-q&quot; &#39;ruby-indent-exp)







172

  (define-key ruby-mode-map &quot;\t&quot; &#39;ruby-indent-command)







173

  (define-key ruby-mode-map &quot;\C-c\C-e&quot; &#39;ruby-insert-end)







174

  (define-key ruby-mode-map &quot;\C-j&quot; &#39;ruby-reindent-then-newline-and-indent)







175

  (define-key ruby-mode-map &quot;\C-c{&quot; &#39;ruby-toggle-block)







176

  (define-key ruby-mode-map &quot;\C-c\C-u&quot; &#39;uncomment-region))







177









178

(defvar ruby-mode-syntax-table nil







179

  &quot;Syntax table in use in ruby-mode buffers.&quot;)







180









181

(if ruby-mode-syntax-table







182

    ()







183

  (setq ruby-mode-syntax-table (make-syntax-table))







184

  (modify-syntax-entry ?\&#39; &quot;\&quot;&quot; ruby-mode-syntax-table)







185

  (modify-syntax-entry ?\&quot; &quot;\&quot;&quot; ruby-mode-syntax-table)







186

  (modify-syntax-entry ?\` &quot;\&quot;&quot; ruby-mode-syntax-table)







187

  (modify-syntax-entry ?# &quot;&lt;&quot; ruby-mode-syntax-table)







188

  (modify-syntax-entry ?\n &quot;&gt;&quot; ruby-mode-syntax-table)







189

  (modify-syntax-entry ?\\ &quot;\\&quot; ruby-mode-syntax-table)







190

  (modify-syntax-entry ?$ &quot;.&quot; ruby-mode-syntax-table)







191

  (modify-syntax-entry ?? &quot;_&quot; ruby-mode-syntax-table)







192

  (modify-syntax-entry ?_ &quot;_&quot; ruby-mode-syntax-table)







193

  (modify-syntax-entry ?: &quot;_&quot; ruby-mode-syntax-table)







194

  (modify-syntax-entry ?&lt; &quot;.&quot; ruby-mode-syntax-table)







195

  (modify-syntax-entry ?&gt; &quot;.&quot; ruby-mode-syntax-table)







196

  (modify-syntax-entry ?&amp; &quot;.&quot; ruby-mode-syntax-table)







197

  (modify-syntax-entry ?| &quot;.&quot; ruby-mode-syntax-table)







198

  (modify-syntax-entry ?% &quot;.&quot; ruby-mode-syntax-table)







199

  (modify-syntax-entry ?= &quot;.&quot; ruby-mode-syntax-table)







200

  (modify-syntax-entry ?/ &quot;.&quot; ruby-mode-syntax-table)







201

  (modify-syntax-entry ?+ &quot;.&quot; ruby-mode-syntax-table)







202

  (modify-syntax-entry ?* &quot;.&quot; ruby-mode-syntax-table)







203

  (modify-syntax-entry ?- &quot;.&quot; ruby-mode-syntax-table)







204

  (modify-syntax-entry ?\; &quot;.&quot; ruby-mode-syntax-table)







205

  (modify-syntax-entry ?\( &quot;()&quot; ruby-mode-syntax-table)







206

  (modify-syntax-entry ?\) &quot;)(&quot; ruby-mode-syntax-table)







207

  (modify-syntax-entry ?\{ &quot;(}&quot; ruby-mode-syntax-table)







208

  (modify-syntax-entry ?\} &quot;){&quot; ruby-mode-syntax-table)







209

  (modify-syntax-entry ?\[ &quot;(]&quot; ruby-mode-syntax-table)







210

  (modify-syntax-entry ?\] &quot;)[&quot; ruby-mode-syntax-table)







211

  )







212









213

(defcustom ruby-indent-tabs-mode nil







214

  &quot;*Indentation can insert tabs in ruby mode if this is non-nil.&quot;







215

  :type &#39;boolean :group &#39;ruby)







216

(put &#39;ruby-indent-tabs-mode &#39;safe-local-variable &#39;booleanp)







217









218

(defcustom ruby-indent-level 2







219

  &quot;*Indentation of ruby statements.&quot;







220

  :type &#39;integer :group &#39;ruby)







221

(put &#39;ruby-indent-level &#39;safe-local-variable &#39;integerp)







222









223

(defcustom ruby-comment-column 32







224

  &quot;*Indentation column of comments.&quot;







225

  :type &#39;integer :group &#39;ruby)







226

(put &#39;ruby-comment-column &#39;safe-local-variable &#39;integerp)







227









228

(defcustom ruby-deep-arglist t







229

  &quot;*Deep indent lists in parenthesis when non-nil.







230

Also ignores spaces after parenthesis when &#39;space.&quot;







231

  :group &#39;ruby)







232

(put &#39;ruby-deep-arglist &#39;safe-local-variable &#39;booleanp)







233









234

(defcustom ruby-deep-indent-paren &#39;(?\( ?\[ ?\] t)







235

  &quot;*Deep indent lists in parenthesis when non-nil. t means continuous line.







236

Also ignores spaces after parenthesis when &#39;space.&quot;







237

  :group &#39;ruby)







238









239

(defcustom ruby-deep-indent-paren-style &#39;space







240

  &quot;Default deep indent style.&quot;







241

  :options &#39;(t nil space) :group &#39;ruby)







242









243

(defcustom ruby-encoding-map







244

  &#39;((us-ascii       . nil)       ;; Do not put coding: us-ascii







245

    (utf-8          . nil)       ;; Do not put coding: utf-8







246

    (shift-jis      . cp932)     ;; Emacs charset name of Shift_JIS







247

    (shift_jis      . cp932)     ;; MIME charset name of Shift_JIS







248

    (japanese-cp932 . cp932))    ;; Emacs charset name of CP932







249

  &quot;Alist to map encoding name from Emacs to Ruby.







250

Associating an encoding name with nil means it needs not be







251

explicitly declared in magic comment.&quot;







252

  :type &#39;(repeat (cons (symbol :tag &quot;From&quot;) (symbol :tag &quot;To&quot;)))







253

  :group &#39;ruby)







254









255

(defcustom ruby-use-encoding-map t







256

  &quot;*Use `ruby-encoding-map&#39; to set encoding magic comment if this is non-nil.&quot;







257

  :type &#39;boolean :group &#39;ruby)







258









259

(defvar ruby-indent-point nil &quot;internal variable&quot;)







260









261

(eval-when-compile (require &#39;cl))







262

(defun ruby-imenu-create-index-in-block (prefix beg end)







263

  (let ((index-alist &#39;()) (case-fold-search nil)







264

        name next pos decl sing)







265

    (goto-char beg)







266

    (while (re-search-forward &quot;^\\s *\\(\\(class\\s +\\|\\(class\\s *&lt;&lt;\\s *\\)\\|module\\s +\\)\\([^\(&lt;\n ]+\\)\\|\\(def\\|alias\\)\\s +\\([^\(\n ]+\\)\\)&quot; end t)







267

      (setq sing (match-beginning 3))







268

      (setq decl (match-string 5))







269

      (setq next (match-end 0))







270

      (setq name (or (match-string 4) (match-string 6)))







271

      (setq pos (match-beginning 0))







272

      (cond







273

       ((string= &quot;alias&quot; decl)







274

        (if prefix (setq name (concat prefix name)))







275

        (push (cons name pos) index-alist))







276

       ((string= &quot;def&quot; decl)







277

        (if prefix







278

            (setq name







279

                  (cond







280

                   ((string-match &quot;^self\.&quot; name)







281

                    (concat (substring prefix 0 -1) (substring name 4)))







282

                  (t (concat prefix name)))))







283

        (push (cons name pos) index-alist)







284

        (ruby-accurate-end-of-block end))







285

       (t







286

        (if (string= &quot;self&quot; name)







287

            (if prefix (setq name (substring prefix 0 -1)))







288

          (if prefix (setq name (concat (substring prefix 0 -1) &quot;::&quot; name)))







289

          (push (cons name pos) index-alist))







290

        (ruby-accurate-end-of-block end)







291

        (setq beg (point))







292

        (setq index-alist







293

              (nconc (ruby-imenu-create-index-in-block







294

                      (concat name (if sing &quot;.&quot; &quot;#&quot;))







295

                      next beg) index-alist))







296

        (goto-char beg))))







297

    index-alist))







298









299

(defun ruby-imenu-create-index ()







300

  (nreverse (ruby-imenu-create-index-in-block nil (point-min) nil)))







301









302

(defun ruby-accurate-end-of-block (&amp;optional end)







303

  (let (state)







304

    (or end (setq end (point-max)))







305

    (while (and (setq state (apply &#39;ruby-parse-partial end state))







306

                (&gt;= (nth 2 state) 0) (&lt; (point) end)))))







307









308

(defun ruby-mode-variables ()







309

  (set-syntax-table ruby-mode-syntax-table)







310

  (setq show-trailing-whitespace t)







311

  (setq local-abbrev-table ruby-mode-abbrev-table)







312

  (make-local-variable &#39;indent-line-function)







313

  (setq indent-line-function &#39;ruby-indent-line)







314

  (make-local-variable &#39;require-final-newline)







315

  (setq require-final-newline t)







316

  (make-local-variable &#39;comment-start)







317

  (setq comment-start &quot;# &quot;)







318

  (make-local-variable &#39;comment-end)







319

  (setq comment-end &quot;&quot;)







320

  (make-local-variable &#39;comment-column)







321

  (setq comment-column ruby-comment-column)







322

  (make-local-variable &#39;comment-start-skip)







323

  (setq comment-start-skip &quot;#+ *&quot;)







324

  (setq indent-tabs-mode ruby-indent-tabs-mode)







325

  (make-local-variable &#39;parse-sexp-ignore-comments)







326

  (setq parse-sexp-ignore-comments t)







327

  (make-local-variable &#39;parse-sexp-lookup-properties)







328

  (setq parse-sexp-lookup-properties t)







329

  (make-local-variable &#39;paragraph-start)







330

  (setq paragraph-start (concat &quot;$\\|&quot; page-delimiter))







331

  (make-local-variable &#39;paragraph-separate)







332

  (setq paragraph-separate paragraph-start)







333

  (make-local-variable &#39;paragraph-ignore-fill-prefix)







334

  (setq paragraph-ignore-fill-prefix t))







335









336

(defun ruby-mode-set-encoding ()







337

  &quot;Insert or update a magic comment header with the proper encoding.







338

`ruby-encoding-map&#39; is looked up to convert an encoding name from







339

Emacs to Ruby.&quot;







340

  (let* ((nonascii







341

          (save-excursion







342

            (widen)







343

            (goto-char (point-min))







344

            (re-search-forward &quot;[^\0-\177]&quot; nil t)))







345

         (coding-system







346

          (or coding-system-for-write







347

              buffer-file-coding-system))







348

         (coding-system







349

          (and coding-system







350

               (coding-system-change-eol-conversion coding-system nil)))







351

         (coding-system







352

          (and coding-system







353

               (or







354

                (coding-system-get coding-system :mime-charset)







355

                (let ((coding-type (coding-system-get coding-system :coding-type)))







356

                  (cond ((eq coding-type &#39;undecided)







357

                         (if nonascii







358

                             (or (and (coding-system-get coding-system :prefer-utf-8)







359

                                      &#39;utf-8)







360

                                 (coding-system-get default-buffer-file-coding-system :coding-type)







361

                                 &#39;ascii-8bit)))







362

                        ((memq coding-type &#39;(utf-8 shift-jis))







363

                         coding-type)







364

                        (t coding-system))))))







365

         (coding-system







366

          (or coding-system







367

              &#39;us-ascii))







368

         (coding-system







369

          (let ((cons (assq coding-system ruby-encoding-map)))







370

            (if cons (cdr cons) coding-system)))







371

         (coding-system







372

          (and coding-system







373

               (symbol-name coding-system))))







374

    (if coding-system







375

        (save-excursion







376

          (widen)







377

          (goto-char (point-min))







378

          (if (looking-at &quot;^#!&quot;) (beginning-of-line 2))







379

          (cond ((looking-at &quot;\\s *#.*-\*-\\s *\\(en\\)?coding\\s *:\\s *\\([-a-z0-9_]*\\)\\s *\\(;\\|-\*-\\)&quot;)







380

                 (unless (string= (match-string 2) coding-system)







381

                   (goto-char (match-beginning 2))







382

                   (delete-region (point) (match-end 2))







383

                   (and (looking-at &quot;-\*-&quot;)







384

                        (let ((n (skip-chars-backward &quot; &quot;)))







385

                          (cond ((= n 0) (insert &quot;  &quot;) (backward-char))







386

                                ((= n -1) (insert &quot; &quot;))







387

                                ((forward-char)))))







388

                   (insert coding-system)))







389

                ((looking-at &quot;\\s *#.*coding\\s *[:=]&quot;))







390

                (t (when ruby-insert-encoding-magic-comment







391

                     (insert &quot;# -*- coding: &quot; coding-system &quot; -*-\n&quot;))))))))







392









393

(defun ruby-current-indentation ()







394

  (save-excursion







395

    (beginning-of-line)







396

    (back-to-indentation)







397

    (current-column)))







398









399

(defun ruby-indent-line (&amp;optional flag)







400

  &quot;Correct indentation of the current ruby line.&quot;







401

  (ruby-indent-to (ruby-calculate-indent)))







402









403

(defun ruby-indent-command ()







404

  (interactive)







405

  (ruby-indent-line t))







406









407

(defun ruby-indent-to (x)







408

  (if x







409

      (let (shift top beg)







410

        (and (&lt; x 0) (error &quot;invalid nest&quot;))







411

        (setq shift (current-column))







412

        (beginning-of-line)







413

        (setq beg (point))







414

        (back-to-indentation)







415

        (setq top (current-column))







416

        (skip-chars-backward &quot; \t&quot;)







417

        (if (&gt;= shift top) (setq shift (- shift top))







418

          (setq shift 0))







419

        (if (and (bolp)







420

                 (= x top))







421

            (move-to-column (+ x shift))







422

          (move-to-column top)







423

          (delete-region beg (point))







424

          (beginning-of-line)







425

          (indent-to x)







426

          (move-to-column (+ x shift))))))







427









428

(defun ruby-special-char-p (&amp;optional pnt)







429

  (setq pnt (or pnt (point)))







430

  (let ((c (char-before pnt)) (b (and (&lt; (point-min) pnt) (char-before (1- pnt)))))







431

    (cond ((or (eq c ??) (eq c ?$)))







432

          ((and (eq c ?:) (or (not b) (eq (char-syntax b) ? ))))







433

          ((eq c ?\\) (eq b ??)))))







434









435

(defun ruby-singleton-class-p ()







436

  (save-excursion







437

    (forward-word -1)







438

    (and (or (bolp) (not (eq (char-before (point)) ?_)))







439

              (looking-at &quot;class\\s *&lt;&lt;&quot;))))







440









441

(defun ruby-expr-beg (&amp;optional option)







442

  (save-excursion







443

    (store-match-data nil)







444

    (let ((space (skip-chars-backward &quot; \t&quot;))







445

          (start (point)))







446

      (cond







447

       ((bolp) t)







448

       ((progn







449

          (forward-char -1)







450

          (and (looking-at &quot;\\?&quot;)







451

               (or (eq (char-syntax (preceding-char)) ?w)







452

                   (ruby-special-char-p))))







453

        nil)







454

       ((and (eq option &#39;heredoc) (&lt; space 0))







455

        (not (progn (goto-char start) (ruby-singleton-class-p))))







456

       ((or (looking-at ruby-operator-re)







457

            (looking-at &quot;[\\[({,;]&quot;)







458

            (and (looking-at &quot;[!?]&quot;)







459

                 (or (not (eq option &#39;modifier))







460

                     (bolp)







461

                     (save-excursion (forward-char -1) (looking-at &quot;\\Sw$&quot;))))







462

            (and (looking-at ruby-symbol-re)







463

                 (skip-chars-backward ruby-symbol-chars)







464

                 (cond







465

                  ((looking-at (regexp-opt







466

                                (append ruby-block-beg-keywords







467

                                        ruby-block-op-keywords







468

                                        ruby-block-mid-keywords)







469

                                &#39;words))







470

                   (goto-char (match-end 0))







471

                   (not (looking-at &quot;\\s_\\|[!?:]&quot;)))







472

                  ((eq option &#39;expr-qstr)







473

                   (looking-at &quot;[a-zA-Z][a-zA-z0-9_]* +%[^ \t]&quot;))







474

                  ((eq option &#39;expr-re)







475

                   (looking-at &quot;[a-zA-Z][a-zA-z0-9_]* +/[^ \t]&quot;))







476

                  (t nil)))))))))







477









478

(defun ruby-forward-string (term &amp;optional end no-error expand)







479

  (let ((n 1) (c (string-to-char term))







480

        (re (if expand







481

                (concat &quot;[^\\]\\(\\\\\\\\\\)*\\([&quot; term &quot;]\\|\\(#{\\)\\)&quot;)







482

              (concat &quot;[^\\]\\(\\\\\\\\\\)*[&quot; term &quot;]&quot;))))







483

    (while (and (re-search-forward re end no-error)







484

                (if (match-beginning 3)







485

                    (ruby-forward-string &quot;}{&quot; end no-error nil)







486

                  (&gt; (setq n (if (eq (char-before (point)) c)







487

                                     (1- n) (1+ n))) 0)))







488

      (forward-char -1))







489

    (cond ((zerop n))







490

          (no-error nil)







491

          ((error &quot;unterminated string&quot;)))))







492









493

(defun ruby-deep-indent-paren-p (c &amp;optional pos)







494

  (cond ((save-excursion







495

           (if pos (goto-char pos))







496

           (ruby-expr-beg))







497

         nil)







498

        ((listp ruby-deep-indent-paren)







499

         (let ((deep (assoc c ruby-deep-indent-paren)))







500

           (cond (deep







501

                  (or (cdr deep) ruby-deep-indent-paren-style))







502

                 ((memq c ruby-deep-indent-paren)







503

                  ruby-deep-indent-paren-style))))







504

        ((eq c ruby-deep-indent-paren) ruby-deep-indent-paren-style)







505

        ((eq c ?\( ) ruby-deep-arglist)))







506









507

(defun ruby-parse-partial (&amp;optional end in-string nest depth pcol indent)







508

  (or depth (setq depth 0))







509

  (or indent (setq indent 0))







510

  (when (re-search-forward ruby-delimiter end &#39;move)







511

    (let ((pnt (point)) w re expand)







512

      (goto-char (match-beginning 0))







513

      (cond







514

       ((and (memq (char-before) &#39;(?@ ?$)) (looking-at &quot;\\sw&quot;))







515

        (goto-char pnt))







516

       ((looking-at &quot;[\&quot;`]&quot;)            ;skip string







517

        (cond







518

         ((and (not (eobp))







519

               (ruby-forward-string (buffer-substring (point) (1+ (point))) end t t))







520

          nil)







521

         (t







522

          (setq in-string (point))







523

          (goto-char end))))







524

       ((looking-at &quot;&#39;&quot;)







525

        (cond







526

         ((and (not (eobp))







527

               (re-search-forward &quot;[^\\]\\(\\\\\\\\\\)*&#39;&quot; end t))







528

          nil)







529

         (t







530

          (setq in-string (point))







531

          (goto-char end))))







532

       ((looking-at &quot;/=&quot;)







533

        (goto-char pnt))







534

       ((looking-at &quot;/&quot;)







535

        (cond







536

         ((and (not (eobp)) (ruby-expr-beg &#39;expr-re))







537

          (if (ruby-forward-string &quot;/&quot; end t t)







538

              nil







539

            (setq in-string (point))







540

            (goto-char end)))







541

         (t







542

          (goto-char pnt))))







543

       ((looking-at &quot;%&quot;)







544

        (cond







545

         ((and (not (eobp))







546

               (ruby-expr-beg &#39;expr-qstr)







547

               (not (looking-at &quot;%=&quot;))







548

               (looking-at &quot;%[QqrxWw]?\\([^a-zA-Z0-9 \t\n]\\)&quot;))







549

          (goto-char (match-beginning 1))







550

          (setq expand (not (memq (char-before) &#39;(?q ?w))))







551

          (setq w (match-string 1))







552

          (cond







553

           ((string= w &quot;[&quot;) (setq re &quot;][&quot;))







554

           ((string= w &quot;{&quot;) (setq re &quot;}{&quot;))







555

           ((string= w &quot;(&quot;) (setq re &quot;)(&quot;))







556

           ((string= w &quot;&lt;&quot;) (setq re &quot;&gt;&lt;&quot;))







557

           ((and expand (string= w &quot;\\&quot;))







558

            (setq w (concat &quot;\\&quot; w))))







559

          (unless (cond (re (ruby-forward-string re end t expand))







560

                        (expand (ruby-forward-string w end t t))







561

                        (t (re-search-forward







562

                            (if (string= w &quot;\\&quot;)







563

                                &quot;\\\\[^\\]*\\\\&quot;







564

                              (concat &quot;[^\\]\\(\\\\\\\\\\)*&quot; w))







565

                            end t)))







566

            (setq in-string (point))







567

            (goto-char end)))







568

         (t







569

          (goto-char pnt))))







570

       ((looking-at &quot;\\?&quot;)              ;skip ?char







571

        (cond







572

         ((and (ruby-expr-beg)







573

               (looking-at &quot;?\\(\\\\C-\\|\\\\M-\\)*\\\\?.&quot;))







574

          (goto-char (match-end 0)))







575

         (t







576

          (goto-char pnt))))







577

       ((looking-at &quot;\\$&quot;)              ;skip $char







578

        (goto-char pnt)







579

        (forward-char 1))







580

       ((looking-at &quot;#&quot;)                ;skip comment







581

        (forward-line 1)







582

        (goto-char (point))







583

        )







584

       ((looking-at &quot;[\\[{(]&quot;)







585

        (let ((deep (ruby-deep-indent-paren-p (char-after))))







586

          (if (and deep (or (not (eq (char-after) ?\{)) (ruby-expr-beg)))







587

              (progn







588

                (and (eq deep &#39;space) (looking-at &quot;.\\s +[^# \t\n]&quot;)







589

                     (setq pnt (1- (match-end 0))))







590

                (setq nest (cons (cons (char-after (point)) (point)) nest))







591

                (setq pcol (cons (cons pnt depth) pcol))







592

                (setq depth 0))







593

            (setq nest (cons (cons (char-after (point)) pnt) nest))







594

            (setq depth (1+ depth))))







595

        (goto-char pnt)







596

        )







597

       ((looking-at &quot;[])}]&quot;)







598

        (if (ruby-deep-indent-paren-p (matching-paren (char-after))







599

                                      (if nest







600

                                          (cdr (nth 0 nest))







601

                                        (save-excursion







602

                                          (forward-char)







603

                                          (ruby-backward-sexp)







604

                                          (point))))







605

            (setq depth (cdr (car pcol)) pcol (cdr pcol))







606

          (setq depth (1- depth)))







607

        (setq nest (cdr nest))







608

        (goto-char pnt))







609

       ((looking-at ruby-block-end-re)







610

        (if (or (and (not (bolp))







611

                     (progn







612

                       (forward-char -1)







613

                       (setq w (char-after (point)))







614

                       (or (eq ?_ w)







615

                           (eq ?. w))))







616

                (progn







617

                  (goto-char pnt)







618

                  (setq w (char-after (point)))







619

                  (or (eq ?_ w)







620

                      (eq ?! w)







621

                      (eq ?? w))))







622

            nil







623

          (setq nest (cdr nest))







624

          (setq depth (1- depth)))







625

        (goto-char pnt))







626

       ((looking-at &quot;def\\s +[^(\n;]*&quot;)







627

        (if (or (bolp)







628

                (progn







629

                  (forward-char -1)







630

                  (not (eq ?_ (char-after (point))))))







631

            (progn







632

              (setq nest (cons (cons nil pnt) nest))







633

              (setq depth (1+ depth))))







634

        (goto-char (match-end 0)))







635

       ((looking-at (concat &quot;\\_&lt;\\(&quot; ruby-block-beg-re &quot;\\)\\_&gt;&quot;))







636

        (and







637

         (save-match-data







638

           (or (not (looking-at (concat &quot;do&quot; ruby-keyword-end-re)))







639

               (save-excursion







640

                 (back-to-indentation)







641

                 (not (looking-at ruby-non-block-do-re)))))







642

         (or (bolp)







643

             (progn







644

               (forward-char -1)







645

               (setq w (char-after (point)))







646

               (not (or (eq ?_ w)







647

                        (eq ?. w)))))







648

         (goto-char pnt)







649

         (setq w (char-after (point)))







650

         (not (eq ?_ w))







651

         (not (eq ?! w))







652

         (not (eq ?? w))







653

         (not (eq ?: w))







654

         (skip-chars-forward &quot; \t&quot;)







655

         (goto-char (match-beginning 0))







656

         (or (not (looking-at ruby-modifier-re))







657

             (ruby-expr-beg &#39;modifier))







658

         (goto-char pnt)







659

         (setq nest (cons (cons nil pnt) nest))







660

         (setq depth (1+ depth)))







661

        (goto-char pnt))







662

       ((looking-at &quot;:\\([&#39;\&quot;]\\)&quot;)







663

        (goto-char (match-beginning 1))







664

        (ruby-forward-string (buffer-substring (match-beginning 1) (match-end 1)) end))







665

       ((looking-at &quot;:\\([-,.+*/%&amp;|^~&lt;&gt;]=?\\|===?\\|&lt;=&gt;\\|![~=]?\\)&quot;)







666

        (goto-char (match-end 0)))







667

       ((looking-at &quot;:\\([a-zA-Z_][a-zA-Z_0-9]*[!?=]?\\)?&quot;)







668

        (goto-char (match-end 0)))







669

       ((or (looking-at &quot;\\.\\.\\.?&quot;)







670

            (looking-at &quot;\\.[0-9]+&quot;)







671

            (looking-at &quot;\\.[a-zA-Z_0-9]+&quot;)







672

            (looking-at &quot;\\.&quot;))







673

        (goto-char (match-end 0)))







674

       ((looking-at &quot;^=begin&quot;)







675

        (if (re-search-forward &quot;^=end&quot; end t)







676

            (forward-line 1)







677

          (setq in-string (match-end 0))







678

          (goto-char end)))







679

       ((looking-at &quot;&lt;&lt;&quot;)







680

        (cond







681

         ((and (ruby-expr-beg &#39;heredoc)







682

               (looking-at &quot;&lt;&lt;\\(-\\)?\\(\\([\&quot;&#39;`]\\)\\([^\n]+?\\)\\3\\|\\(?:\\sw\\|\\s_\\)+\\)&quot;))







683

          (setq re (regexp-quote (or (match-string 4) (match-string 2))))







684

          (if (match-beginning 1) (setq re (concat &quot;\\s *&quot; re)))







685

          (let* ((id-end (goto-char (match-end 0)))







686

                 (line-end-position (save-excursion (end-of-line) (point)))







687

                 (state (list in-string nest depth pcol indent)))







688

            ;; parse the rest of the line







689

            (while (and (&gt; line-end-position (point))







690

                        (setq state (apply &#39;ruby-parse-partial







691

                                           line-end-position state))))







692

            (setq in-string (car state)







693

                  nest (nth 1 state)







694

                  depth (nth 2 state)







695

                  pcol (nth 3 state)







696

                  indent (nth 4 state))







697

            ;; skip heredoc section







698

            (if (re-search-forward (concat &quot;^&quot; re &quot;$&quot;) end &#39;move)







699

                (forward-line 1)







700

              (setq in-string id-end)







701

              (goto-char end))))







702

         (t







703

          (goto-char pnt))))







704

       ((looking-at &quot;^__END__$&quot;)







705

        (goto-char pnt))







706

       ((looking-at ruby-here-doc-beg-re)







707

        (if (re-search-forward (ruby-here-doc-end-match)







708

                               ruby-indent-point t)







709

            (forward-line 1)







710

          (setq in-string (match-end 0))







711

          (goto-char ruby-indent-point)))







712

       (t







713

        (error (format &quot;bad string %s&quot;







714

                       (buffer-substring (point) pnt)







715

                       ))))))







716

  (list in-string nest depth pcol))







717









718

(defun ruby-parse-region (start end)







719

  (let (state)







720

    (save-excursion







721

      (if start







722

          (goto-char start)







723

        (ruby-beginning-of-indent))







724

      (save-restriction







725

        (narrow-to-region (point) end)







726

        (while (and (&gt; end (point))







727

                    (setq state (apply &#39;ruby-parse-partial end state))))))







728

    (list (nth 0 state)                 ; in-string







729

          (car (nth 1 state))           ; nest







730

          (nth 2 state)                 ; depth







731

          (car (car (nth 3 state)))     ; pcol







732

          ;(car (nth 5 state))          ; indent







733

          )))







734









735

(defun ruby-indent-size (pos nest)







736

  (+ pos (* (or nest 1) ruby-indent-level)))







737









738

(defun ruby-calculate-indent (&amp;optional parse-start)







739

  (save-excursion







740

    (beginning-of-line)







741

    (let ((ruby-indent-point (point))







742

          (case-fold-search nil)







743

          state bol eol begin op-end







744

          (paren (progn (skip-syntax-forward &quot; &quot;)







745

                        (and (char-after) (matching-paren (char-after)))))







746

          (indent 0))







747

      (if parse-start







748

          (goto-char parse-start)







749

        (ruby-beginning-of-indent)







750

        (setq parse-start (point)))







751

      (back-to-indentation)







752

      (setq indent (current-column))







753

      (setq state (ruby-parse-region parse-start ruby-indent-point))







754

      (cond







755

       ((nth 0 state)                   ; within string







756

        (setq indent nil))              ;  do nothing







757

       ((car (nth 1 state))             ; in paren







758

        (goto-char (setq begin (cdr (nth 1 state))))







759

        (let ((deep (ruby-deep-indent-paren-p (car (nth 1 state))







760

                                              (1- (cdr (nth 1 state))))))







761

          (if deep







762

              (cond ((and (eq deep t) (eq (car (nth 1 state)) paren))







763

                     (skip-syntax-backward &quot; &quot;)







764

                     (setq indent (1- (current-column))))







765

                    ((eq deep &#39;space)







766

                     (goto-char (cdr (nth 1 state)))







767

                     (setq indent (1+ (current-column))))







768

                    ((let ((s (ruby-parse-region (point) ruby-indent-point)))







769

                       (and (nth 2 s) (&gt; (nth 2 s) 0)







770

                            (or (goto-char (cdr (nth 1 s))) t)))







771

                     (forward-word -1)







772

                     (setq indent (ruby-indent-size (current-column) (nth 2 state))))







773

                    (t







774

                     (setq indent (current-column))







775

                     (cond ((eq deep &#39;space))







776

                           (paren (setq indent (1- indent)))







777

                           (t (setq indent (ruby-indent-size (1- indent) 1))))))







778

            (if (nth 3 state) (goto-char (nth 3 state))







779

              (goto-char parse-start) (back-to-indentation))







780

            (setq indent (ruby-indent-size (current-column) (nth 2 state))))







781

          (and (eq (car (nth 1 state)) paren)







782

               (ruby-deep-indent-paren-p (matching-paren paren)







783

                                         (1- (cdr (nth 1 state))))







784

               (search-backward (char-to-string paren))







785

               (setq indent (current-column)))))







786

       ((and (nth 2 state) (&gt; (nth 2 state) 0)) ; in nest







787

        (if (null (cdr (nth 1 state)))







788

            (error &quot;invalid nest&quot;))







789

        (goto-char (cdr (nth 1 state)))







790

        (forward-word -1)               ; skip back a keyword







791

        (setq begin (point))







792

        (cond







793

         ((looking-at &quot;do\\&gt;[^_]&quot;)      ; iter block is a special case







794

          (if (nth 3 state) (goto-char (nth 3 state))







795

            (goto-char parse-start) (back-to-indentation))







796

          (setq indent (ruby-indent-size (current-column) (nth 2 state))))







797

         (t







798

          (setq indent (+ (current-column) ruby-indent-level)))))







799









800

       ((and (nth 2 state) (&lt; (nth 2 state) 0)) ; in negative nest







801

        (setq indent (ruby-indent-size (current-column) (nth 2 state)))))







802

      (when indent







803

        (goto-char ruby-indent-point)







804

        (end-of-line)







805

        (setq eol (point))







806

        (beginning-of-line)







807

        (cond







808

         ((and (not (ruby-deep-indent-paren-p paren







809

                                              (and (cdr (nth 1 state))







810

                                                   (1- (cdr (nth 1 state))))))







811

               (re-search-forward ruby-negative eol t))







812

          (and (not (eq ?_ (char-after (match-end 0))))







813

               (setq indent (- indent ruby-indent-level))))







814

         ((and







815

           (save-excursion







816

             (beginning-of-line)







817

             (not (bobp)))







818

           (or (ruby-deep-indent-paren-p t)







819

               (null (car (nth 1 state)))))







820

          ;; goto beginning of non-empty no-comment line







821

          (let (end done)







822

            (while (not done)







823

              (skip-chars-backward &quot; \t\n&quot;)







824

              (setq end (point))







825

              (beginning-of-line)







826

              (if (re-search-forward &quot;^\\s *#&quot; end t)







827

                  (beginning-of-line)







828

                (setq done t))))







829

          (setq bol (point))







830

          (end-of-line)







831

          ;; skip the comment at the end







832

          (skip-chars-backward &quot; \t&quot;)







833

          (let (end (pos (point)))







834

            (beginning-of-line)







835

            (while (and (re-search-forward &quot;#&quot; pos t)







836

                        (setq end (1- (point)))







837

                        (or (ruby-special-char-p end)







838

                            (and (setq state (ruby-parse-region parse-start end))







839

                                 (nth 0 state))))







840

              (setq end nil))







841

            (goto-char (or end pos))







842

            (skip-chars-backward &quot; \t&quot;)







843

            (setq begin (if (and end (nth 0 state)) pos (cdr (nth 1 state))))







844

            (setq state (ruby-parse-region parse-start (point))))







845

          (or (bobp) (forward-char -1))







846

          (and







847

           (or (and (looking-at ruby-symbol-re)







848

                    (skip-chars-backward ruby-symbol-chars)







849

                    (looking-at (concat &quot;\\&lt;\\(&quot; ruby-block-hanging-re &quot;\\)\\&gt;&quot;))







850

                    (not (eq (point) (nth 3 state)))







851

                    (save-excursion







852

                      (goto-char (match-end 0))







853

                      (not (looking-at &quot;[a-z_]&quot;))))







854

               (and (looking-at ruby-operator-re)







855

                    (not (ruby-special-char-p))







856

                    ;; operator at the end of line







857

                    (let ((c (char-after (point))))







858

                      (and







859

;;                     (or (null begin)







860

;;                         (save-excursion







861

;;                           (goto-char begin)







862

;;                           (skip-chars-forward &quot; \t&quot;)







863

;;                           (not (or (eolp) (looking-at &quot;#&quot;)







864

;;                                    (and (eq (car (nth 1 state)) ?{)







865

;;                                         (looking-at &quot;|&quot;))))))







866

                       (or (not (eq ?/ c))







867

                           (null (nth 0 (ruby-parse-region (or begin parse-start) (point)))))







868

                       (or (not (eq ?| (char-after (point))))







869

                           (save-excursion







870

                             (or (eolp) (forward-char -1))







871

                             (cond







872

                              ((search-backward &quot;|&quot; nil t)







873

                               (skip-chars-backward &quot; \t\n&quot;)







874

                               (and (not (eolp))







875

                                    (progn







876

                                      (forward-char -1)







877

                                      (not (looking-at &quot;{&quot;)))







878

                                    (progn







879

                                      (forward-word -1)







880

                                      (not (looking-at &quot;do\\&gt;[^_]&quot;)))))







881

                              (t t))))







882

                       (not (eq ?, c))







883

                       (setq op-end t)))))







884

           (setq indent







885

                 (cond







886

                  ((and







887

                    (null op-end)







888

                    (not (looking-at (concat &quot;\\&lt;\\(&quot; ruby-block-hanging-re &quot;\\)\\&gt;&quot;)))







889

                    (eq (ruby-deep-indent-paren-p t) &#39;space)







890

                    (not (bobp)))







891

                   (widen)







892

                   (goto-char (or begin parse-start))







893

                   (skip-syntax-forward &quot; &quot;)







894

                   (current-column))







895

                  ((car (nth 1 state)) indent)







896

                  (t







897

                   (+ indent ruby-indent-level))))))))







898

      (goto-char ruby-indent-point)







899

      (beginning-of-line)







900

      (skip-syntax-forward &quot; &quot;)







901

      (if (looking-at &quot;\\.[^.]&quot;)







902

          (+ indent ruby-indent-level)







903

        indent))))







904









905

(defun ruby-electric-brace (arg)







906

  (interactive &quot;P&quot;)







907

  (insert-char last-command-event 1)







908

  (ruby-indent-line t)







909

  (delete-char -1)







910

  (self-insert-command (prefix-numeric-value arg)))







911









912

(eval-when-compile







913

  (defmacro defun-region-command (func args &amp;rest body)







914

    (let ((intr (car body)))







915

      (when (featurep &#39;xemacs)







916

        (if (stringp intr) (setq intr (cadr body)))







917

        (and (eq (car intr) &#39;interactive)







918

             (setq intr (cdr intr))







919

             (setcar intr (concat &quot;_&quot; (car intr)))))







920

      (cons &#39;defun (cons func (cons args body))))))







921









922

(defun-region-command ruby-beginning-of-defun (&amp;optional arg)







923

  &quot;Move backward to next beginning-of-defun.







924

With argument, do this that many times.







925

Returns t unless search stops due to end of buffer.&quot;







926

  (interactive &quot;p&quot;)







927

  (and (re-search-backward (concat &quot;^\\(&quot; ruby-block-beg-re &quot;\\)\\_&gt;&quot;)







928

                           nil &#39;move (or arg 1))







929

       (progn (beginning-of-line) t)))







930









931

(defun ruby-beginning-of-indent ()







932

  (and (re-search-backward (concat &quot;^\\(&quot; ruby-indent-beg-re &quot;\\)\\_&gt;&quot;)







933

                           nil &#39;move)







934

       (progn







935

         (beginning-of-line)







936

         t)))







937









938

(defun-region-command ruby-end-of-defun (&amp;optional arg)







939

  &quot;Move forward to next end of defun.







940

An end of a defun is found by moving forward from the beginning of one.&quot;







941

  (interactive &quot;p&quot;)







942

  (and (re-search-forward (concat &quot;^\\(&quot; ruby-block-end-re &quot;\\)\\($\\|\\b[^_]\\)&quot;)







943

                          nil &#39;move (or arg 1))







944

       (progn (beginning-of-line) t))







945

  (forward-line 1))







946









947

(defun ruby-move-to-block (n)







948

  (let (start pos done down (orig (point)))







949

    (setq start (ruby-calculate-indent))







950

    (setq down (looking-at (if (&lt; n 0) ruby-block-end-re







951

                             (concat &quot;\\&lt;\\(&quot; ruby-block-beg-re &quot;\\)\\&gt;&quot;))))







952

    (while (and (not done) (not (if (&lt; n 0) (bobp) (eobp))))







953

      (forward-line n)







954

      (cond







955

       ((looking-at &quot;^\\s *$&quot;))







956

       ((looking-at &quot;^\\s *#&quot;))







957

       ((and (&gt; n 0) (looking-at &quot;^=begin\\&gt;&quot;))







958

        (re-search-forward &quot;^=end\\&gt;&quot;))







959

       ((and (&lt; n 0) (looking-at &quot;^=end\\&gt;&quot;))







960

        (re-search-backward &quot;^=begin\\&gt;&quot;))







961

       (t







962

        (setq pos (current-indentation))







963

        (cond







964

         ((&lt; start pos)







965

          (setq down t))







966

         ((and down (= pos start))







967

          (setq done t))







968

         ((&gt; start pos)







969

          (setq done t)))))







970

      (if done







971

          (save-excursion







972

            (back-to-indentation)







973

            (if (looking-at (concat &quot;\\&lt;\\(&quot; ruby-block-mid-re &quot;\\)\\&gt;&quot;))







974

                (setq done nil)))))







975

    (back-to-indentation)







976

    (when (&lt; n 0)







977

      (let ((eol (point-at-eol)) state next)







978

        (if (&lt; orig eol) (setq eol orig))







979

        (setq orig (point))







980

        (while (and (setq next (apply &#39;ruby-parse-partial eol state))







981

                    (&lt; (point) eol))







982

          (setq state next))







983

        (when (cdaadr state)







984

          (goto-char (cdaadr state)))







985

        (backward-word)))))







986









987

(defun-region-command ruby-beginning-of-block (&amp;optional arg)







988

  &quot;Move backward to next beginning-of-block&quot;







989

  (interactive &quot;p&quot;)







990

  (ruby-move-to-block (- (or arg 1))))







991









992

(defun-region-command ruby-end-of-block (&amp;optional arg)







993

  &quot;Move forward to next beginning-of-block&quot;







994

  (interactive &quot;p&quot;)







995

  (ruby-move-to-block (or arg 1)))







996









997

(defun-region-command ruby-forward-sexp (&amp;optional cnt)







998

  (interactive &quot;p&quot;)







999

  (if (and (numberp cnt) (&lt; cnt 0))







1000

      (ruby-backward-sexp (- cnt))







1001

    (let ((i (or cnt 1)))







1002

      (condition-case nil







1003

          (while (&gt; i 0)







1004

            (skip-syntax-forward &quot; &quot;)







1005

            (if (looking-at &quot;,\\s *&quot;) (goto-char (match-end 0)))







1006

            (cond ((looking-at &quot;\\?\\(\\\\[CM]-\\)*\\\\?\\S &quot;)







1007

                   (goto-char (match-end 0)))







1008

                  ((progn







1009

                     (skip-chars-forward &quot;,.:;|&amp;^~=!?\\+\\-\\*&quot;)







1010

                     (looking-at &quot;\\s(&quot;))







1011

                   (goto-char (scan-sexps (point) 1)))







1012

                  ((and (looking-at (concat &quot;\\&lt;\\(&quot; ruby-block-beg-re &quot;\\)\\&gt;&quot;))







1013

                        (not (eq (char-before (point)) ?.))







1014

                        (not (eq (char-before (point)) ?:)))







1015

                   (ruby-end-of-block)







1016

                   (forward-word 1))







1017

                  ((looking-at &quot;\\(\\$\\|@@?\\)?\\sw&quot;)







1018

                   (while (progn







1019

                            (while (progn (forward-word 1) (looking-at &quot;_&quot;)))







1020

                            (cond ((looking-at &quot;::&quot;) (forward-char 2) t)







1021

                                  ((&gt; (skip-chars-forward &quot;.&quot;) 0))







1022

                                  ((looking-at &quot;\\?\\|!\\(=[~=&gt;]\\|[^~=]\\)&quot;)







1023

                                   (forward-char 1) nil)))))







1024

                  ((let (state expr)







1025

                     (while







1026

                         (progn







1027

                           (setq expr (or expr (ruby-expr-beg)







1028

                                          (looking-at &quot;%\\sw?\\Sw\\|[\&quot;&#39;`/]&quot;)))







1029

                           (nth 1 (setq state (apply &#39;ruby-parse-partial nil state))))







1030

                       (setq expr t)







1031

                       (skip-chars-forward &quot;&lt;&quot;))







1032

                     (not expr))))







1033

            (setq i (1- i)))







1034

        ((error) (forward-word 1)))







1035

      i)))







1036









1037

(defun-region-command ruby-backward-sexp (&amp;optional cnt)







1038

  (interactive &quot;p&quot;)







1039

  (if (and (numberp cnt) (&lt; cnt 0))







1040

      (ruby-forward-sexp (- cnt))







1041

    (let ((i (or cnt 1)))







1042

      (condition-case nil







1043

          (while (&gt; i 0)







1044

            (skip-chars-backward &quot; \t\n,.:;|&amp;^~=!?\\+\\-\\*&quot;)







1045

            (forward-char -1)







1046

            (cond ((looking-at &quot;\\s)&quot;)







1047

                   (goto-char (scan-sexps (1+ (point)) -1))







1048

                   (case (char-before)







1049

                     (?% (forward-char -1))







1050

                     (&#39;(?q ?Q ?w ?W ?r ?x)







1051

                      (if (eq (char-before (1- (point))) ?%) (forward-char -2))))







1052

                   nil)







1053

                  ((looking-at &quot;\\s\&quot;\\|\\\\\\S_&quot;)







1054

                   (let ((c (char-to-string (char-before (match-end 0)))))







1055

                     (while (and (search-backward c)







1056

                                 (oddp (skip-chars-backward &quot;\\&quot;)))))







1057

                   nil)







1058

                  ((looking-at &quot;\\s.\\|\\s\\&quot;)







1059

                   (if (ruby-special-char-p) (forward-char -1)))







1060

                  ((looking-at &quot;\\s(&quot;) nil)







1061

                  (t







1062

                   (forward-char 1)







1063

                   (while (progn (forward-word -1)







1064

                                 (case (char-before)







1065

                                   (?_ t)







1066

                                   (?. (forward-char -1) t)







1067

                                   ((?$ ?@)







1068

                                    (forward-char -1)







1069

                                    (and (eq (char-before) (char-after)) (forward-char -1)))







1070

                                   (?:







1071

                                    (forward-char -1)







1072

                                    (eq (char-before) :)))))







1073

                   (if (looking-at ruby-block-end-re)







1074

                       (ruby-beginning-of-block))







1075

                   nil))







1076

            (setq i (1- i)))







1077

        ((error)))







1078

      i)))







1079









1080

(defun ruby-reindent-then-newline-and-indent ()







1081

  (interactive &quot;*&quot;)







1082

  (newline)







1083

  (save-excursion







1084

    (end-of-line 0)







1085

    (indent-according-to-mode)







1086

    (delete-region (point) (progn (skip-chars-backward &quot; \t&quot;) (point))))







1087

  (indent-according-to-mode))







1088









1089

(fset &#39;ruby-encomment-region (symbol-function &#39;comment-region))







1090









1091

(defun ruby-decomment-region (beg end)







1092

  (interactive &quot;r&quot;)







1093

  (save-excursion







1094

    (goto-char beg)







1095

    (while (re-search-forward &quot;^\\([ \t]*\\)#&quot; end t)







1096

      (replace-match &quot;\\1&quot; nil nil)







1097

      (save-excursion







1098

        (ruby-indent-line)))))







1099









1100

(defun ruby-insert-end ()







1101

  (interactive)







1102

  (insert &quot;end&quot;)







1103

  (ruby-indent-line t)







1104

  (end-of-line))







1105









1106

(defun ruby-mark-defun ()







1107

  &quot;Put mark at end of this Ruby function, point at beginning.&quot;







1108

  (interactive)







1109

  (push-mark (point))







1110

  (ruby-end-of-defun)







1111

  (push-mark (point) nil t)







1112

  (ruby-beginning-of-defun)







1113

  (re-search-backward &quot;^\n&quot; (- (point) 1) t))







1114









1115

(defun ruby-indent-exp (&amp;optional shutup-p)







1116

  &quot;Indent each line in the balanced expression following point syntactically.







1117

If optional SHUTUP-P is non-nil, no errors are signalled if no







1118

balanced expression is found.&quot;







1119

  (interactive &quot;*P&quot;)







1120

  (let ((here (point-marker)) start top column (nest t))







1121

    (set-marker-insertion-type here t)







1122

    (unwind-protect







1123

        (progn







1124

          (beginning-of-line)







1125

          (setq start (point) top (current-indentation))







1126

          (while (and (not (eobp))







1127

                      (progn







1128

                        (setq column (ruby-calculate-indent start))







1129

                        (cond ((&gt; column top)







1130

                               (setq nest t))







1131

                              ((and (= column top) nest)







1132

                               (setq nest nil) t))))







1133

            (ruby-indent-to column)







1134

            (beginning-of-line 2)))







1135

      (goto-char here)







1136

      (set-marker here nil))))







1137









1138

(defun ruby-add-log-current-method ()







1139

  &quot;Return current method string.&quot;







1140

  (condition-case nil







1141

      (save-excursion







1142

        (let (mname mlist (indent 0))







1143

          ;; get current method (or class/module)







1144

          (if (re-search-backward







1145

               (concat &quot;^[ \t]*\\(def\\|class\\|module\\)[ \t]+&quot;







1146

                       &quot;\\(&quot;







1147

                       ;; \\. and :: for class method







1148

                        &quot;\\([A-Za-z_]&quot; ruby-symbol-re &quot;*\\|\\.\\|::&quot; &quot;\\)&quot;







1149

                        &quot;+\\)&quot;)







1150

               nil t)







1151

              (progn







1152

                (setq mname (match-string 2))







1153

                (unless (string-equal &quot;def&quot; (match-string 1))







1154

                  (setq mlist (list mname) mname nil))







1155

                (goto-char (match-beginning 1))







1156

                (setq indent (current-column))







1157

                (beginning-of-line)))







1158

          ;; nest class/module







1159

          (while (and (&gt; indent 0)







1160

                      (re-search-backward







1161

                       (concat







1162

                        &quot;^[ \t]*\\(class\\|module\\)[ \t]+&quot;







1163

                        &quot;\\([A-Z]&quot; ruby-symbol-re &quot;*\\)&quot;)







1164

                       nil t))







1165

            (goto-char (match-beginning 1))







1166

            (if (&lt; (current-column) indent)







1167

                (progn







1168

                  (setq mlist (cons (match-string 2) mlist))







1169

                  (setq indent (current-column))







1170

                  (beginning-of-line))))







1171

          (when mname







1172

            (let ((mn (split-string mname &quot;\\.\\|::&quot;)))







1173

              (if (cdr mn)







1174

                  (progn







1175

                    (cond







1176

                     ((string-equal &quot;&quot; (car mn))







1177

                      (setq mn (cdr mn) mlist nil))







1178

                     ((string-equal &quot;self&quot; (car mn))







1179

                      (setq mn (cdr mn)))







1180

                     ((let ((ml (nreverse mlist)))







1181

                        (while ml







1182

                          (if (string-equal (car ml) (car mn))







1183

                              (setq mlist (nreverse (cdr ml)) ml nil))







1184

                          (or (setq ml (cdr ml)) (nreverse mlist))))))







1185

                    (if mlist







1186

                        (setcdr (last mlist) mn)







1187

                      (setq mlist mn))







1188

                    (setq mn (last mn 2))







1189

                    (setq mname (concat &quot;.&quot; (cadr mn)))







1190

                    (setcdr mn nil))







1191

                (setq mname (concat &quot;#&quot; mname)))))







1192

          ;; generate string







1193

          (if (consp mlist)







1194

              (setq mlist (mapconcat (function identity) mlist &quot;::&quot;)))







1195

          (if mname







1196

              (if mlist (concat mlist mname) mname)







1197

            mlist)))))







1198









1199

(defun ruby-brace-to-do-end ()







1200

  (when (looking-at &quot;{&quot;)







1201

    (let ((orig (point)) (end (progn (ruby-forward-sexp) (point)))







1202

          oneline (end (make-marker)))







1203

      (setq oneline (and (eolp) (&lt;= (point-at-bol) orig)))







1204

      (when (eq (char-before) ?\})







1205

        (delete-char -1)







1206

        (cond







1207

         (oneline







1208

          (insert &quot;\n&quot;)







1209

          (set-marker end (point)))







1210

         ((eq (char-syntax (preceding-char)) ?w)







1211

          (insert &quot; &quot;)))







1212

        (insert &quot;end&quot;)







1213

        (if (eq (char-syntax (following-char)) ?w)







1214

            (insert &quot; &quot;))







1215

        (goto-char orig)







1216

        (delete-char 1)







1217

        (if (eq (char-syntax (preceding-char)) ?w)







1218

            (insert &quot; &quot;))







1219

        (insert &quot;do&quot;)







1220

        (when (looking-at &quot;\\sw\\||&quot;)







1221

          (insert &quot; &quot;)







1222

          (backward-char))







1223

        (when oneline







1224

          (setq orig (point))







1225

          (when (cond







1226

                 ((looking-at &quot;\\s *|&quot;)







1227

                  (goto-char (match-end 0))







1228

                  (and (search-forward &quot;|&quot; (point-at-eol) &#39;move)







1229

                       (not (eolp))))







1230

                 (t))







1231

            (while (progn







1232

                     (insert &quot;\n&quot;)







1233

                     (ruby-forward-sexp)







1234

                     (looking-at &quot;\\s *;\\s *&quot;))







1235

              (delete-char (- (match-end 0) (match-beginning 0))))







1236

            (goto-char orig)







1237

            (beginning-of-line 2)







1238

            (indent-region (point) end))







1239

          (goto-char orig))







1240

        t))))







1241









1242

(defun ruby-do-end-to-brace ()







1243

  (when (and (or (bolp)







1244

                 (not (memq (char-syntax (preceding-char)) &#39;(?w ?_))))







1245

             (looking-at &quot;\\&lt;do\\(\\s \\|$\\)&quot;))







1246

    (let ((orig (point)) (end (progn (ruby-forward-sexp) (point)))







1247

          first last)







1248

      (backward-char 3)







1249

      (when (looking-at ruby-block-end-re)







1250

        (delete-char 3)







1251

        (insert &quot;}&quot;)







1252

        (setq last (and (eolp)







1253

                        (progn (backward-char 1)







1254

                               (skip-syntax-backward &quot; &quot;)







1255

                               (bolp))







1256

                        (1- (point-at-eol -1))))







1257

        (goto-char orig)







1258

        (delete-char 2)







1259

        (insert &quot;{&quot;)







1260

        (setq orig (point))







1261

        (when (and last (&lt;= last (point))







1262

                   (not (search-forward &quot;#&quot; (setq first (point-at-eol)) t)))







1263

          (goto-char (- end 4))







1264

          (end-of-line 0)







1265

          (if (looking-at &quot;\n\\s *&quot;)







1266

              (delete-char (- (match-end 0) (match-beginning 0))) t)







1267

          (goto-char first)







1268

          (if (looking-at &quot;\n\\s *&quot;)







1269

              (delete-char (- (match-end 0) (match-beginning 0))) t))







1270

        (goto-char orig)







1271

        (if (looking-at &quot;\\s +|&quot;)







1272

            (delete-char (- (match-end 0) (match-beginning 0) 1)))







1273

        t))))







1274









1275

(defun ruby-toggle-block ()







1276

  (interactive)







1277

  (or (ruby-brace-to-do-end)







1278

      (ruby-do-end-to-brace)))







1279









1280

(eval-when-compile







1281

  (if (featurep &#39;font-lock)







1282

      (defmacro eval-when-font-lock-available (&amp;rest args) (cons &#39;progn args))







1283

    (defmacro eval-when-font-lock-available (&amp;rest args))))







1284









1285

(eval-when-compile







1286

  (if (featurep &#39;hilit19)







1287

      (defmacro eval-when-hilit19-available (&amp;rest args) (cons &#39;progn args))







1288

    (defmacro eval-when-hilit19-available (&amp;rest args))))







1289









1290

(eval-when-font-lock-available







1291

  (or (boundp &#39;font-lock-variable-name-face)







1292

      (setq font-lock-variable-name-face font-lock-type-face))







1293









1294

  (defconst ruby-font-lock-syntactic-keywords







1295

        `(







1296

          ;; #{ }, #$hoge, #@foo are not comments







1297

          (&quot;\\(#\\)[{$@]&quot; 1 (1 . nil))







1298

          ;; the last $&#39;, $&quot;, $` in the respective string is not variable







1299

          ;; the last ?&#39;, ?&quot;, ?` in the respective string is not ascii code







1300

          (&quot;\\(^\\|[\[ \t\n&lt;+\(,=]\\)\\([&#39;\&quot;`]\\)\\(\\\\.\\|\\2\\|[^&#39;\&quot;`\n\\\\]\\)*?\\\\?[?$]\\(\\2\\)&quot;







1301

           (2 (7 . nil))







1302

           (4 (7 . nil)))







1303

          ;; $&#39; $&quot; $` .... are variables







1304

          ;; ?&#39; ?&quot; ?` are ascii codes







1305

          (&quot;\\(^\\|[^\\\\]\\)\\(\\\\\\\\\\)*[?$]\\([#\&quot;&#39;`]\\)&quot; 3 (1 . nil))







1306

          ;; regexps







1307

          (&quot;\\(^\\|[[=(,~?:;&lt;&gt;]\\|\\(^\\|\\s \\)\\(if\\|elsif\\|unless\\|while\\|until\\|when\\|and\\|or\\|&amp;&amp;\\|||\\)\\|g?sub!?\\|scan\\|split!?\\)\\s *\\(/\\)[^/\n\\\\]*\\(\\\\.[^/\n\\\\]*\\)*\\(/\\)&quot;







1308

           (4 (7 . ?/))







1309

           (6 (7 . ?/)))







1310

          (&quot;^\\(=\\)begin\\(\\s \\|$\\)&quot; 1 (7 . nil))







1311

          (&quot;^\\(=\\)end\\(\\s \\|$\\)&quot; 1 (7 . nil))







1312

          (,(concat ruby-here-doc-beg-re &quot;.*\\(\n\\)&quot;)







1313

           ,(+ 1 (regexp-opt-depth ruby-here-doc-beg-re))







1314

           (ruby-here-doc-beg-syntax))







1315

          (,ruby-here-doc-end-re 3 (ruby-here-doc-end-syntax))))







1316









1317

  (unless (functionp &#39;syntax-ppss)







1318

    (defun syntax-ppss (&amp;optional pos)







1319

      (parse-partial-sexp (point-min) (or pos (point)))))







1320









1321

  (defun ruby-in-ppss-context-p (context &amp;optional ppss)







1322

    (let ((ppss (or ppss (syntax-ppss (point)))))







1323

      (if (cond







1324

           ((eq context &#39;anything)







1325

            (or (nth 3 ppss)







1326

                (nth 4 ppss)))







1327

           ((eq context &#39;string)







1328

            (nth 3 ppss))







1329

           ((eq context &#39;heredoc)







1330

            (and (nth 3 ppss)







1331

                 ;; If it&#39;s generic string, it&#39;s a heredoc and we don&#39;t care







1332

                 ;; See `parse-partial-sexp&#39;







1333

                 (not (numberp (nth 3 ppss)))))







1334

           ((eq context &#39;non-heredoc)







1335

            (and (ruby-in-ppss-context-p &#39;anything)







1336

                 (not (ruby-in-ppss-context-p &#39;heredoc))))







1337

           ((eq context &#39;comment)







1338

            (nth 4 ppss))







1339

           (t







1340

            (error (concat







1341

                    &quot;Internal error on `ruby-in-ppss-context-p&#39;: &quot;







1342

                    &quot;context name `&quot; (symbol-name context) &quot;&#39; is unknown&quot;))))







1343

          t)))







1344









1345

  (defun ruby-in-here-doc-p ()







1346

    (save-excursion







1347

      (let ((old-point (point)) (case-fold-search nil))







1348

        (beginning-of-line)







1349

        (catch &#39;found-beg







1350

          (while (and (re-search-backward ruby-here-doc-beg-re nil t)







1351

                      (not (ruby-singleton-class-p)))







1352

            (if (not (or (ruby-in-ppss-context-p &#39;anything)







1353

                         (ruby-here-doc-find-end old-point)))







1354

                (throw &#39;found-beg t)))))))







1355









1356

  (defun ruby-here-doc-find-end (&amp;optional limit)







1357

    &quot;Expects the point to be on a line with one or more heredoc







1358

openers. Returns the buffer position at which all heredocs on the







1359

line are terminated, or nil if they aren&#39;t terminated before the







1360

buffer position `limit&#39; or the end of the buffer.&quot;







1361

    (save-excursion







1362

      (beginning-of-line)







1363

      (catch &#39;done







1364

        (let ((eol (save-excursion (end-of-line) (point)))







1365

              (case-fold-search nil)







1366

              ;; Fake match data such that (match-end 0) is at eol







1367

              (end-match-data (progn (looking-at &quot;.*$&quot;) (match-data)))







1368

              beg-match-data end-re)







1369

          (while (re-search-forward ruby-here-doc-beg-re eol t)







1370

            (setq beg-match-data (match-data))







1371

            (setq end-re (ruby-here-doc-end-match))







1372









1373

            (set-match-data end-match-data)







1374

            (goto-char (match-end 0))







1375

            (unless (re-search-forward end-re limit t) (throw &#39;done nil))







1376

            (setq end-match-data (match-data))







1377









1378

            (set-match-data beg-match-data)







1379

            (goto-char (match-end 0)))







1380

          (set-match-data end-match-data)







1381

          (goto-char (match-end 0))







1382

          (point)))))







1383









1384

  (defun ruby-here-doc-beg-syntax ()







1385

    (save-excursion







1386

      (goto-char (match-beginning 0))







1387

      (unless (or (ruby-in-ppss-context-p &#39;non-heredoc)







1388

                  (ruby-in-here-doc-p))







1389

        (string-to-syntax &quot;|&quot;))))







1390









1391

  (defun ruby-here-doc-end-syntax ()







1392

    (let ((pss (syntax-ppss)) (case-fold-search nil))







1393

      (when (ruby-in-ppss-context-p &#39;heredoc pss)







1394

        (save-excursion







1395

          (goto-char (nth 8 pss))     ; Go to the beginning of heredoc.







1396

          (let ((eol (point)))







1397

            (beginning-of-line)







1398

            (if (and (re-search-forward (ruby-here-doc-beg-match) eol t) ; If there is a heredoc that matches this line...







1399

                     (not (ruby-in-ppss-context-p &#39;anything)) ; And that&#39;s not inside a heredoc/string/comment...







1400

                     (progn (goto-char (match-end 0)) ; And it&#39;s the last heredoc on its line...







1401

                            (not (re-search-forward ruby-here-doc-beg-re eol t))))







1402

                (string-to-syntax &quot;|&quot;)))))))







1403









1404

  (eval-when-compile







1405

      (put &#39;ruby-mode &#39;font-lock-defaults







1406

           &#39;((ruby-font-lock-keywords)







1407

             nil nil nil







1408

             beginning-of-line







1409

             (font-lock-syntactic-keywords







1410

              . ruby-font-lock-syntactic-keywords))))







1411









1412

  (defun ruby-font-lock-docs (limit)







1413

    (if (re-search-forward &quot;^=begin\\(\\s \\|$\\)&quot; limit t)







1414

        (let (beg)







1415

          (beginning-of-line)







1416

          (setq beg (point))







1417

          (forward-line 1)







1418

          (if (re-search-forward &quot;^=end\\(\\s \\|$\\)&quot; limit t)







1419

              (progn







1420

                (set-match-data (list beg (point)))







1421

                t)))))







1422









1423

  (defun ruby-font-lock-maybe-docs (limit)







1424

    (let (beg)







1425

      (save-excursion







1426

        (if (and (re-search-backward &quot;^=\\(begin\\|end\\)\\(\\s \\|$\\)&quot; nil t)







1427

                 (string= (match-string 1) &quot;begin&quot;))







1428

            (progn







1429

              (beginning-of-line)







1430

              (setq beg (point)))))







1431

      (if (and beg (and (re-search-forward &quot;^=\\(begin\\|end\\)\\(\\s \\|$\\)&quot; nil t)







1432

                        (string= (match-string 1) &quot;end&quot;)))







1433

          (progn







1434

            (set-match-data (list beg (point)))







1435

            t)







1436

        nil)))







1437









1438

  (defvar ruby-font-lock-syntax-table







1439

    (let* ((tbl (copy-syntax-table ruby-mode-syntax-table)))







1440

      (modify-syntax-entry ?_ &quot;w&quot; tbl)







1441

      tbl))







1442









1443

  (defconst ruby-font-lock-keywords







1444

    (list







1445

     ;; functions







1446

     &#39;(&quot;^\\s *def\\s +\\([^( \t\n]+\\)&quot;







1447

       1 font-lock-function-name-face)







1448

     ;; keywords







1449

     (cons (concat







1450

            &quot;\\(^\\|[^_:.@$]\\|\\.\\.\\)\\_&lt;\\(defined\\?\\|&quot;







1451

            (regexp-opt







1452

             &#39;(&quot;alias&quot;







1453

               &quot;and&quot;







1454

               &quot;begin&quot;







1455

               &quot;break&quot;







1456

               &quot;case&quot;







1457

               &quot;catch&quot;







1458

               &quot;class&quot;







1459

               &quot;def&quot;







1460

               &quot;do&quot;







1461

               &quot;elsif&quot;







1462

               &quot;else&quot;







1463

               &quot;fail&quot;







1464

               &quot;ensure&quot;







1465

               &quot;for&quot;







1466

               &quot;end&quot;







1467

               &quot;if&quot;







1468

               &quot;in&quot;







1469

               &quot;module&quot;







1470

               &quot;next&quot;







1471

               &quot;not&quot;







1472

               &quot;or&quot;







1473

               &quot;raise&quot;







1474

               &quot;redo&quot;







1475

               &quot;rescue&quot;







1476

               &quot;retry&quot;







1477

               &quot;return&quot;







1478

               &quot;then&quot;







1479

               &quot;throw&quot;







1480

               &quot;super&quot;







1481

               &quot;unless&quot;







1482

               &quot;undef&quot;







1483

               &quot;until&quot;







1484

               &quot;when&quot;







1485

               &quot;while&quot;







1486

               &quot;yield&quot;







1487

               )







1488

             t)







1489

            &quot;\\)&quot;







1490

            ruby-keyword-end-re)







1491

           2)







1492

     ;; here-doc beginnings







1493

     (list ruby-here-doc-beg-re 0 &#39;font-lock-string-face)







1494

     ;; variables







1495

     &#39;(&quot;\\(^\\|[^_:.@$]\\|\\.\\.\\)\\_&lt;\\(nil\\|self\\|true\\|false\\)\\&gt;&quot;







1496

       2 font-lock-variable-name-face)







1497

     ;; variables







1498

     &#39;(&quot;\\(\\$\\([^a-zA-Z0-9 \n]\\|[0-9]\\)\\)\\W&quot;







1499

       1 font-lock-variable-name-face)







1500

     &#39;(&quot;\\(\\$\\|@\\|@@\\)\\(\\w\\|_\\)+&quot;







1501

       0 font-lock-variable-name-face)







1502

     ;; embedded document







1503

     &#39;(ruby-font-lock-docs







1504

       0 font-lock-comment-face t)







1505

     &#39;(ruby-font-lock-maybe-docs







1506

       0 font-lock-comment-face t)







1507

     ;; general delimited string







1508

     &#39;(&quot;\\(^\\|[[ \t\n&lt;+(,=]\\)\\(%[xrqQwW]?\\([^&lt;[{(a-zA-Z0-9 \n]\\)[^\n\\\\]*\\(\\\\.[^\n\\\\]*\\)*\\(\\3\\)\\)&quot;







1509

       (2 font-lock-string-face))







1510

     ;; constants







1511

     &#39;(&quot;\\(^\\|[^_]\\)\\_&lt;\\([A-Z]+\\(\\w\\|_\\)*\\)&quot;







1512

       2 font-lock-type-face)







1513

     ;; symbols







1514

     &#39;(&quot;\\(^\\|[^:]\\)\\(:\\([-+~]@?\\|[/%&amp;|^`]\\|\\*\\*?\\|&lt;\\(&lt;\\|=&gt;?\\)?\\|&gt;[&gt;=]?\\|===?\\|=~\\|![~=]?\\|\\[\\]=?\\|\\(\\w\\|_\\)+\\([!?=]\\|\\b_*\\)\\|#{[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\)\\)&quot;







1515

       2 font-lock-reference-face)







1516

     &#39;(&quot;\\(^\\s *\\|[\[\{\(,]\\s *\\|\\sw\\s +\\)\\(\\(\\sw\\|_\\)+\\):[^:]&quot; 2 font-lock-reference-face)







1517

     ;; expression expansion







1518

     &#39;(&quot;#\\({[^}\n\\\\]*\\(\\\\.[^}\n\\\\]*\\)*}\\|\\(\\$\\|@\\|@@\\)\\(\\w\\|_\\)+\\)&quot;







1519

       0 font-lock-variable-name-face t)







1520

     ;; warn lower camel case







1521

     ;&#39;(&quot;\\&lt;[a-z]+[a-z0-9]*[A-Z][A-Za-z0-9]*\\([!?]?\\|\\&gt;\\)&quot;







1522

     ;  0 font-lock-warning-face)







1523

     )







1524

    &quot;*Additional expressions to highlight in ruby mode.&quot;))







1525









1526

(eval-when-hilit19-available







1527

  (hilit-set-mode-patterns







1528

   &#39;ruby-mode







1529

   &#39;((&quot;[^$\\?]\\(\&quot;[^\\\&quot;]*\\(\\\\\\(.\\|\n\\)[^\\\&quot;]*\\)*\&quot;\\)&quot; 1 string)







1530

     (&quot;[^$\\?]\\(&#39;[^\\&#39;]*\\(\\\\\\(.\\|\n\\)[^\\&#39;]*\\)*&#39;\\)&quot; 1 string)







1531

     (&quot;[^$\\?]\\(`[^\\`]*\\(\\\\\\(.\\|\n\\)[^\\`]*\\)*`\\)&quot; 1 string)







1532

     (&quot;^\\s *#.*$&quot; nil comment)







1533

     (&quot;[^$@?\\]\\(#[^$@{\n].*$\\)&quot; 1 comment)







1534

     (&quot;[^a-zA-Z_]\\(\\?\\(\\\\[CM]-\\)*.\\)&quot; 1 string)







1535

     (&quot;^\\s *\\(require\\|load\\).*$&quot; nil include)







1536

     (&quot;^\\s *\\(include\\|alias\\|undef\\).*$&quot; nil decl)







1537

     (&quot;^\\s *\\&lt;\\(class\\|def\\|module\\)\\&gt;&quot; &quot;[)\n;]&quot; defun)







1538

     (&quot;[^_]\\&lt;\\(begin\\|case\\|else\\|elsif\\|end\\|ensure\\|for\\|if\\|unless\\|rescue\\|then\\|when\\|while\\|until\\|do\\|yield\\)\\&gt;\\([^_]\\|$\\)&quot; 1 defun)







1539

     (&quot;[^_]\\&lt;\\(and\\|break\\|next\\|raise\\|fail\\|in\\|not\\|or\\|redo\\|retry\\|return\\|super\\|yield\\|catch\\|throw\\|self\\|nil\\)\\&gt;\\([^_]\\|$\\)&quot; 1 keyword)







1540

     (&quot;\\$\\(.\\|\\sw+\\)&quot; nil type)







1541

     (&quot;[$@].[a-zA-Z_0-9]*&quot; nil struct)







1542

     (&quot;^__END__&quot; nil label))))







1543









1544









1545

;;;###autoload







1546

(defun ruby-mode ()







1547

  &quot;Major mode for editing ruby scripts.







1548

\\[ruby-indent-command] properly indents subexpressions of multi-line







1549

class, module, def, if, while, for, do, and case statements, taking







1550

nesting into account.







1551









1552

The variable ruby-indent-level controls the amount of indentation.







1553

\\{ruby-mode-map}&quot;







1554

  (interactive)







1555

  (kill-all-local-variables)







1556

  (use-local-map ruby-mode-map)







1557

  (setq mode-name &quot;Ruby&quot;)







1558

  (setq major-mode &#39;ruby-mode)







1559

  (ruby-mode-variables)







1560









1561

  (make-local-variable &#39;imenu-create-index-function)







1562

  (setq imenu-create-index-function &#39;ruby-imenu-create-index)







1563









1564

  (make-local-variable &#39;add-log-current-defun-function)







1565

  (setq add-log-current-defun-function &#39;ruby-add-log-current-method)







1566









1567

  (add-hook







1568

   (cond ((boundp &#39;before-save-hook)







1569

          (make-local-variable &#39;before-save-hook)







1570

          &#39;before-save-hook)







1571

         ((boundp &#39;write-contents-functions) &#39;write-contents-functions)







1572

         ((boundp &#39;write-contents-hooks) &#39;write-contents-hooks))







1573

   &#39;ruby-mode-set-encoding)







1574









1575

  (set (make-local-variable &#39;font-lock-defaults) &#39;((ruby-font-lock-keywords) nil nil))







1576

  (set (make-local-variable &#39;font-lock-keywords) ruby-font-lock-keywords)







1577

  (set (make-local-variable &#39;font-lock-syntax-table) ruby-font-lock-syntax-table)







1578

  (set (make-local-variable &#39;font-lock-syntactic-keywords) ruby-font-lock-syntactic-keywords)







1579









1580

  (if (fboundp &#39;run-mode-hooks)







1581

      (run-mode-hooks &#39;ruby-mode-hook)







1582

    (run-hooks &#39;ruby-mode-hook)))







1583









1584

(provide &#39;ruby-mode)











Properties



Name
Value





svn:eol-style

LF




svn:keywords

Revision












&nbsp;
ViewVC Help


Powered by ViewVC 1.1.5
&nbsp;





